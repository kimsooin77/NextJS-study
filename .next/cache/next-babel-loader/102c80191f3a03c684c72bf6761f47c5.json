{"ast":null,"code":"import { all, fork } from 'redux-saga/effects';\nimport axios from 'axios';\nimport postSaga from './post';\nimport userSaga from './user';\naxios.defaults.baseURL = 'http://localhost:3065';\nexport default function* rootSaga() {\n  yield all([fork(postSaga), fork(userSaga)]);\n} // all은 배열 안에 있는 것을 모두 실행\n// put은 dispatch와 같은 역할\n// fork와 call의 차이점 : fork는 비동기 함수 호출이고 call은 동기 함수 호출\n// 즉 fork로 호출하면 결과값이 다 받아와지지 않았음에도 불구하고 action을 실행하고\n// call로 호출하면 결과값이 다 받아와진 이후에 action 실행(await 같은 역할)\n// call(logInAPI, action.data) 오른쪽 코드와 같음 logInAPI(action.data)\n// 간단하게 코드 대체가 가능한데 call과 yield와 같은 effect, 제너레이터를  사용하는 이유\n// 에러가 났을 때 코드 한줄한줄 테스트해 볼 수 있기 때문에\n// yield와 take는 딱 한번만 실행됨 따라서 while이나 takeEvery라는 effect을 써서 무한 반복되게 함\n// while take는 동기적으로 동작하지만 takeEvery는 비동기로 동작한다는 차이가 있다.\n// 보통 while은 직관적이지도 않고 코드상으로 보기도 좋지 않아 takeEvery를 주로 씀\n// takeLatest란 실수로 로그인 버튼을 연속으로 누르거나 포스팅 버튼을 연속으로 누르거나와 같은 연속적인\n// 액션이 일어날때 같은 로딩상태이면(이미 완료된 건 취소X) 앞의 액션은 무시되고 마지막 액션만 실행되게 하는 effect\n// 이때 주의점은 프론트가 백엔드에 요청을 두번 했을 때 응답이 한번만 되는 것이지 요청이 한번만 들어오게 하는 것은 아니다.\n// 결론 서버에는 데이터가 두 번 저장되는 것\n// 따라서 위와 같이 요청이 두 번 서버에 저장되는걸 막기 위해 throttle을 사용한다.\n// 예를 들어 throttle (\"ADD_POST_REQUEST\", addPost, 2000) 이면 2초 안에는 액션이 1번만 보내지도록 제한을 두는 것\n// 보통 throttle은 특수한 경우에만 쓰고 takeLastest를 사용하고 백엔드에서 액션을 점검하는 편","map":{"version":3,"sources":["C:/Users/kimsooin/Desktop/공부기록/공부기록/22.04 공부기록/next-study/front/sagas/index.js"],"names":["all","fork","axios","postSaga","userSaga","defaults","baseURL","rootSaga"],"mappings":"AAAA,SAAQA,GAAR,EAAaC,IAAb,QAAwB,oBAAxB;AACA,OAAOC,KAAP,MAAkB,OAAlB;AAEA,OAAOC,QAAP,MAAqB,QAArB;AACA,OAAOC,QAAP,MAAqB,QAArB;AAEAF,KAAK,CAACG,QAAN,CAAeC,OAAf,GAAyB,uBAAzB;AAEA,eAAe,UAAUC,QAAV,GAAqB;AAChC,QAAMP,GAAG,CAAC,CACNC,IAAI,CAACE,QAAD,CADE,EAENF,IAAI,CAACG,QAAD,CAFE,CAAD,CAAT;AAIH,C,CAED;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA","sourcesContent":["import {all, fork} from 'redux-saga/effects';\r\nimport axios from 'axios';\r\n\r\nimport postSaga from './post';\r\nimport userSaga from './user';\r\n\r\naxios.defaults.baseURL = 'http://localhost:3065';\r\n\r\nexport default function* rootSaga() {\r\n    yield all([\r\n        fork(postSaga),\r\n        fork(userSaga),\r\n    ]);\r\n}\r\n\r\n// all은 배열 안에 있는 것을 모두 실행\r\n// put은 dispatch와 같은 역할\r\n// fork와 call의 차이점 : fork는 비동기 함수 호출이고 call은 동기 함수 호출\r\n// 즉 fork로 호출하면 결과값이 다 받아와지지 않았음에도 불구하고 action을 실행하고\r\n// call로 호출하면 결과값이 다 받아와진 이후에 action 실행(await 같은 역할)\r\n// call(logInAPI, action.data) 오른쪽 코드와 같음 logInAPI(action.data)\r\n\r\n// 간단하게 코드 대체가 가능한데 call과 yield와 같은 effect, 제너레이터를  사용하는 이유\r\n// 에러가 났을 때 코드 한줄한줄 테스트해 볼 수 있기 때문에\r\n\r\n// yield와 take는 딱 한번만 실행됨 따라서 while이나 takeEvery라는 effect을 써서 무한 반복되게 함\r\n// while take는 동기적으로 동작하지만 takeEvery는 비동기로 동작한다는 차이가 있다.\r\n// 보통 while은 직관적이지도 않고 코드상으로 보기도 좋지 않아 takeEvery를 주로 씀\r\n\r\n// takeLatest란 실수로 로그인 버튼을 연속으로 누르거나 포스팅 버튼을 연속으로 누르거나와 같은 연속적인\r\n// 액션이 일어날때 같은 로딩상태이면(이미 완료된 건 취소X) 앞의 액션은 무시되고 마지막 액션만 실행되게 하는 effect\r\n// 이때 주의점은 프론트가 백엔드에 요청을 두번 했을 때 응답이 한번만 되는 것이지 요청이 한번만 들어오게 하는 것은 아니다.\r\n// 결론 서버에는 데이터가 두 번 저장되는 것\r\n\r\n// 따라서 위와 같이 요청이 두 번 서버에 저장되는걸 막기 위해 throttle을 사용한다.\r\n// 예를 들어 throttle (\"ADD_POST_REQUEST\", addPost, 2000) 이면 2초 안에는 액션이 1번만 보내지도록 제한을 두는 것\r\n// 보통 throttle은 특수한 경우에만 쓰고 takeLastest를 사용하고 백엔드에서 액션을 점검하는 편"]},"metadata":{},"sourceType":"module"}